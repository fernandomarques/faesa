<!doctype html>
<html lang="pt">

	<head>
		<meta charset="utf-8">

		<title>Complexidade de Algoritmos</title>

		<meta name="author" content="Fernando Antonio Marques Filho">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="../css/reveal.css">
		<link rel="stylesheet" href="../css/theme/sky.css" id="theme">
		<link rel="stylesheet" href="../css/misc.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="../lib/css/zenburn.css">
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../css/print/pdf.css' : '../css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>
	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h3>P = NP ? E algoritmos</h3>					<p>
						<small>Created by Fernando Marques </small>
					</p>
		</section>
		<section data-markdown>
			## NP-Completos
			- Quase todos algoritmos que estudamos até agora são de tempo polinomialmente complexos
			- Para uma entrada _n_ seu tempo de execução no pior caso é de $O(n^k) $
			- Poderíamos imaginar que isso seria verdadeiro para TODOS os problemas
			- Um exemplo é o "problema da parada" de Turing que não pode ser resolvido por qualquer computador, não importa por quanto tempo seja executa
			- Em geral pensamos que problemas que podem ser resolvidos por algoritmo em tempo polinomial são tratáveis, ou fáceis
			- Já os superpolinomiais são intratáveis ou difíceis
		</section>
		<section data-markdown>
			## NP-Completos
			- Problemas NP-Completos tem _status_ desconhecidos, não foram encontrados nenhum algoritmo polinomial para solucionar-los
			- Mas também não existe nenhuma prova de que não exista uma solução polinomial
			- Essa questão denominada $ P \neq NP $ continua sendo um dos mais profundos e intrigantes problemas de pesquisa ainda em aberto na teoria
			da ciência da computação, desde que foi proposto pela primeira vez em 1971
			- [Video NP](https://www.youtube.com/watch?v=YX40hbAHx3s)
			- [Problema da Parada de Turing](https://www.youtube.com/watch?v=92WHN-pAFCs)
		</section>
		<section data-markdown>
			## Problemas NP-Completos
			- Caminhos simples mínimos e caminho simples de comprimento máximo
				- Determinar se um grafo contém um caminho simples com pelo menos um determinado número de arestas
				é NP-Completo
			- Passeio de Euler e Ciclo hamiltoniano
				- Um passeio de euler de um grafo conexo dirigido é um ciclo que percorre cada aresta
				exatamente uma vez, mas pode visitar cada vértice mais de uma vez
				- Um ciclo hamiltoniano é um ciclo simples que contém cada vértice, determinar se um grafo tem um
				ciclo hamiltoniano é difícil!
		</section>
		<section data-markdown>
			## P, NP, NPC
			- P: consiste nos problemas que podem ser resolvidos em tempo polinomial, mais especificamente, são problemas
			que podem ser resolvidos no tempo $O(n^k)$
			- A classe NP consiste nos problemas que são __verificáveis__ em tempo polinomial. 
				- Se tivéssemos um certificado de solução, poderíamos verificar se o certificado é correto em tempo polinomial
			- NPC, ou NP-Completo, é um problema que está em NP e é tão difícil quanto qualquer problema em NP
			- Se __existe um__ problema NPC que possa ser resolvido em tempo polinomial, então, __TODOS__ problemas NP
			tem um algoritmo em tempo polinomial
	</section>
	<section data-markdown>
		![XKCD Caixeiro Viajante](https://imgs.xkcd.com/comics/travelling_salesman_problem.png)
	</section>
	<section data-markdown>
		![XKCD NPC](https://imgs.xkcd.com/comics/np_complete.png)
	</section>
	<section data-markdown>
		## Como mostrar que um problema é NPC
		- Quando dizemos que um problema é NPC dizemos que trata-se de um problema difícil de resolver
		- Não tentamos provar um algoritmo eficiênte, mas que provavelmente não existe nenhum algoritmo eficiênte
		- De certa forma tentamos mostrar o limite inferior
	</section>
	<section data-markdown>
		## Decisão _versus_ otimização
		- Problemas de otimização tem um valor associado e desejamos encontrar uma solução viável com o melhor valor
		- Por exemplo, encontrar o menor caminho (menor número de arestas) entre dois vértices u e v 
		- A NP-Completude não se aplica diretamente a problemas de otimização e sim problemas de Decisão
		- Nos problemas de decisão a resposta é apenas __sim__ ou __não__
	</section>
	<section data-markdown>
		## Decisão _versus_ otimização
		- Embora os problemas NPC estejam confinados ao reino dos problemas de decisão, podemos tirar proveito
		de uma relação conveniente entre problemas de otimização e decisão
		- Exemplo.: Dao um grafo dirigido G, vértices u e v, e um inteiro k, existe um caminho de u e v que consiste em no
		máximo k arestas?
		- Essa relação age a nosso favor ao mostrar que um problema de otimização é difícil
		- Assim, se o problema de decisão é difícil, o problema de otimização é ao menos tão difícil quanto
	</section>
	<section data-markdown>
		## Reduções
		- Mostrar que um problema não é mais difícil ou não é mais fácil que outro também se aplica quando ambos são
		problemas de decisão
		- Denominamos a entrada de um problema por __instância__ desse problema
		- Suponha que sabemos resolver um problema de decisão diferente B em tempo polinomial
		- Finalmente, suponha que temos um procedimento que transforma qualquer instância &alpha; de A em uma instância 
		&beta; de B com as seguintes características
			- A transformação demora tempo polinomial
			- As respostas são as mesma, se um é sim, o outro também
	</section>
	<section data-markdown>
		## Reduções
		- Denominamos tal procedimento um __algoritmo de redução__, ele proporciona um meio para resolver A em tempo polinomial
			1. Dada uma instância &alpha; do problema A, use um algoritmo de redução de tempo polinomial
			para transformá-la em uma instância &beta; de B
			2. Execute o algoritmo de redução de tempo polinomial para B para a instância &beta;
			3. Use a resposta de &beta; como resposta para &alpha;
		- A NP-Completude consiste em mostrar o quanto um problema é difícil, e não, fácil
	</section>
	<section data-markdown>
		## Reduções
		- Suponha que tenhamos um problema de decisão A que saibamos que não pode haver nenhum algoritmo polinomial
		- Suponha que tenhamos uma redução polinomial para B
		- Por contradição mostramos que não pode existir nenhum algoritmo de tempo polinomial para B
		- Suponha que B tenha tempo polinomial
		- Logo, teríamos uma forma de resolver o problema A em tempo polinomial, o que contradiz a hipótese
	</section>
	<section data-markdown>
		## Reduções
		- Para NP-Completude não podemos supor que não exista absolutamente nenhum algoritmo de tempo polinomial
		- Contudo, a metodologia da prova é semelhante no sentido que provamos que se A é NPC então B também é
		- Como o problema da redução se baseia no fato de ter um problema conhecidamente NPC, para provar um
		problema diferente precisamos de um "primeiro" problema NPC
	</section>
	<section data-markdown>
		## O primeiro problema
		> Temos um circuito combinacional booleano composto por portas AND, OR e NOT, e desejamos saber se existe um conjunto
		de entradas booleanas para esse circuito que faça sua saída ser 1.
	</section>
	<section data-markdown>
		## Tempo Polinomial
		- Problemas polinomiais são considerados tratáveis mais por questões filosóficas do que matemáticas
		- Temos três argumentações:
			1. Embora seja razoável considerar um problema $\Theta(n^{100})$ como intratável, poucos problemas tem essa ordem
			polinômio. Normalmente, assim que uma solução polinomial é encontrada, algoritmos mais eficiêntes são encontrados em seguida. 

	</section>
	<section data-markdown>
		## Tempo Polinomial
		- 2- A classe de problemas polinomiais resolvidos pela máquina de acesso aleatório serial é igual à classe
			de problemas resolvíveis em tempo polinomial em máquinas abstratas de Turing, que também é igual
			aos problemas resolvíveis em tempo polinomial em um computador paralelo quando o número de processadores cresce
			polinomialmente com o tamanho da entrada
	</section>
	<section data-markdown>
		## Tempo Polinomial
		- 3- A classe de problemas resolvíveis em tempo polinomial tem propriedades de fechamento interessantes, 
		já que os polinômios são fechados por multiplicação, adição e composição
		- Se a saída de um algoritmo polinomial é alimentada na entrada de outro, o algoritmo composto é polinomial
		- Se um algoritmo chama sub-rotinas de tempo polinomial e realiza uma quantidade adicional de trabalho, também
		polinomial, a execução do algoritmo é polinomial
	</section>
	<section data-markdown>
		## Problemas abstratos
		- Para entender a classe de problemas de tempo polinomial resolvíveis, precisamos de uma noção de o que é problema
		- Um __problema abstrato__ Q é uma relação binária entre um conjunto _I_ de instâncias e um conjunto _S_ de soluções
		- Uma instância do menor-caminho é um grafo com dois vértices
		- Uma solução é uma sequência de vértices no gráfo, talvez uma sequência vazia. Sendo o menor caminho, pode ter mais de uma solução
		</section>
	<section data-markdown>
		## Problemas abstratos
		- Vimos que a NP-Completude se restringe a __problemas de decisão__
		- Esse problema pode ser uma função que mapeia uma instância i = {G,u,v,k} para PATH(i) = 1 se existe um 
		caminho mínimo de u a v com no máximo k arestas ou PATH(i) = 0 caso contrário
		- Apesar de muitos problemas abstratos serem de otimização, vimos que podemos reformular para um problema de decisão
		que não é mais difícil que o primeiro
		</section>
		<section data-markdown>
			## Verificação em tempo polinomial
			- Agora examinaremos algoritmos que "verificam" soluções
			- Dado a instância {G,u,v,k} do problema de decisão, é fácil verificar se o caminho p é um caminho
			em G, e se o comprimento de p é no máximo k. 
			- Podemos visualizar p como um certificado de que a instância de fato pertence a PATH
			- Para o problema de decisão PATH o certificado não nos dá muito, afinal, $ PATH \in P $, assim
			podemos verificar a validade de p em tempo polinomial! Basta refazer do zero...
		</section>
		<section data-markdown>
			## Ciclos Hamiltonianos
			- É um problema estudado a mais de 100 anos
			- Um __ciclo hamiltoniano__ de um grafo não dirigido G = (V,E) é um ciclo simples que contém cada vértice
			de V. 
			- O nome é uma homenagem a W.R. Hamilton, que descreveu o jogo no dodecaedro. No qual o jogador fixa cinco alfinetes
			em quaisquer cinco vértices consecutivos e o outro jogador deve completar o caminho para formar um ciclo que tenha todos os vértices
			- Podemos definir o problema como: "Um grafo G tem um ciclo hamiltoniano?"
		</section>
		<section data-markdown>
			## Ciclos Hamiltonianos
			- Uma solução seria gerar todas as permutações dos vértices de G e depois verificar cada permutação
			para ver se ela é um caminho hamiltoniano
			- Se usarmos a codificação de um grafo como sua matriz de adjacência, um número $m$ de vértices no grafo
			será $\Omega(\sqrt n)$, onde $n$ igual comprimento da codificação de G
			- Existem $m!$ permutações, portanto $\Omega(m!) = \Omega(\sqrt n!) = \Omega(2^{\sqrt n})$
			- Que não é $O(n^k)$ para nenhuma constante $k$
			- Assim esse algoritmo não é polinomial, na verdade, é NP-Completo

		</section>
		<section data-markdown>
			## Algoritmo de Verificação
			- Se um amigo diz que um gráfico é hamiltoniano e oferece como certificado a sequência de vértices
			- Para verificar basta confirmar que ele é uma permutação dos vértices de V e que cada uma das arestas consecutivas realmente existe
			- Seria possível identificar que isso é verdade usando um algoritmo $O(n^2)$
			- Assim, uma uma prova de que um ciclo hamiltoniano existe em um grafo pode ser verificada em tempo polinomial
		</section>
	<section data-markdown>
		## RSA
		- [Video RSA](https://www.youtube.com/watch?v=wXB-V_Keiu8)
	</section>
	</div>
		</div>

		<script src="../lib/js/head.min.js"></script>
		<script src="../js/reveal.js"></script>
		<script src="../js/base.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				slideNumber: 'c/t',

				transition: 'slide', // none/fade/slide/convex/concave/zoom
				math: {
					// mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
					config: 'TeX-AMS_HTML-full',
					TeX: {
						Macros: {
							R: '\\mathbb{R}',
							set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
						}
					}
				},
				// Optional reveal.js plugins
				dependencies: [
          { src: '../lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../plugin/zoom-js/zoom.js', async: true },
					{ src: '../plugin/notes/notes.js', async: true },
					{ src: '../plugin/math/math.js', async: true }
				]
			});

		</script>

	</body>
</html>
